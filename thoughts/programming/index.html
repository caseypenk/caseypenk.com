<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="/styles.css">
    <meta charset="UTF-8">
    <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" /><!-- Style: Space Zero -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>casey penk</title>
</head>
<body>
    <div id="main-content">
    <h1><a href="https://caseypenk.com">casey penk</a></h1>
    <h1 class="subtitle">reinventing programming</h1>
    <br />
      <p>Friendly. Collaborative. Inspiring.</p><p>When you think of programming, do any of those words come to mind? Probably not.</p><p>When we talk about the accessibility of computer science <span style="font-size:small">–</span>&nbsp;and technology in general <span style="font-size:small">–&nbsp;</span>we often frame the our concerns in one particular way: <strong>How do we get more women in the industry?</strong> That's a problematic approach. For one, it suggests that women are at fault for simply not realizing the virtues of programming. It's borne of a paternalistic instinct: that we know what's best for you, and that <em>if you only learn Java</em> you'll make tons of money and find a nice man. This is obviously a poor&nbsp;way to change an industry, let alone human behavior.</p><p>Framing the issue in terms of proportions (between men and women) is helpful, because it gives us an objective measuring stick. But it's also a cop out. We give too much weight to that lone metric. We think that that once we meet a certain quota, we're good. The tech industry&nbsp;is off the hook. That's too simplistic an approach. What happens when we stop paying attention and the demographics revert back?</p><p>Recruiting is about more than advertising perks.&nbsp;Does anyone really think the promise of maternity leave alone is enough to inspire someone to change careers? To choose what she's going to do for the rest of her life, a person needs deeper motivation. Our goal shouldn't be to appear inclusive by&nbsp;recruiting inclusively, but to be inclusive in everything we do. It's got to be systemic.</p><p>Similarly, I see well-intentioned efforts to make computer science education more inclusive and accessible. But if so many people are struggling so hard to effectively teach these topics, is that a problem with the educators&nbsp;or a problem with the field? There's only so many ways to put a positive spin on bad news.&nbsp;Many people avoid coding because they find the languages, and the field in general, obtuse. But instead of tackling the root of the problem, we&nbsp;force students to adapt to the arbitrary and confusing approaches that already exist.</p><p><!--EndFragment--></p><p>What if education and recruiting are only part of the problem? <!--StartFragment--></p><p><strong>What if programming itself is broken?</strong></p><p> </p><p><!--EndFragment--></p><p><!--EndFragment--></p><p><!--EndFragment--></p><h2>Imagine</h2><p><!--StartFragment-->Imagine programming as a person. Someone&nbsp;you have a relationship with. Maybe it's friendly or even loving. But there's a good chance it's strained, even hostile. Sometimes a little of both. Imagine someone who…</p><ul><li>forces you to talk to them in exactly the right way or they will literally shut down on you</li><li>reminds you literally every time you mess up, but stays silent every time you succeed</li><li>complains about you without giving any suggestions about what you should do differently. You're left to guess and try a bunch of different things in an attempt to make it right, but you're not sure if anything will stick until it does. You often don't know why doing what you did fixed the problem, but it works so&nbsp;<a target="_blank" href="http://en.wikipedia.org/wiki/Kludge">you keep doing it anyway</a></li><li>forces you to read a manual before you even get to talk with them</li><li>only allows you to do one type of activity (say, bowling) with them. If you want to do any other activity you'll need to find someone else</li><li>lacks a sense of humor or fun</li><li>just isn't friendly</li></ul><p><strong>Would you want to be friends with them</strong><strong>?</strong>&nbsp;Well, no.&nbsp;If we wouldn't let friends treat us this way, why do we let programming treat us this way?&nbsp;It makes sense that so many people, including many women, aren't interested in programming.&nbsp;Now imagine a friend who…</p><ul><li>speaks your language&nbsp;– even if you have a heavy accent</li><li>acknowledges your successes</li><li>helps you learn and grow from your mistakes by suggesting instead of just criticizing</li><li>makes the first move by suggesting things you can do together, even if you're not sure yourself yet</li><li>has a spontaneous attitude –&nbsp;down to do anything, anywhere</li><li>lightens up the mood and encourages you even when things are going poorly</li><li>treats you like a human</li></ul><p>You'll notice a vivid contrast between the frenemy we have today&nbsp;and the friend we want&nbsp;soon. To improve the situation, we need to fix&nbsp;our whole approach.</p><p><strong>It's time to reinvent programming.</strong></p><p> </p><p><!--EndFragment--></p><h2>how do we fix it?</h2><p>A few principles need to guide our efforts. First, we need to think&nbsp;from the perspective of the 99% – those&nbsp;who've never programmed in a meaningful way. These are the people we're trying to reach; we're empowering them to create amazing things. We also need to frame this in the context of the twenty-first century. The technologies at our disposal, and the kinds of things people want from technology, are almost entirely different from when most programming languages were developed&nbsp;– in the 60s, 70s, 80s, and 90s. It's strange that we're still using these technologies, and the methodologies that accompany&nbsp;them, to&nbsp;solve modern problems.</p><p> </p><h3>Step 1: Reinvent the language</h3><p>A language –&nbsp;whether a human language or a computer language –&nbsp;is just a tool. It shouldn't determine what we say or how we think. It should stay in the background and facilitate rather than dictate what we're doing. So why do we let computer languages be so difficult to learn and use? And why do we keep around so many of them? The reasons are largely historical: they each served a different purpose, and they grew up organically, so no one really crafted the overall structure. Because anyone can invent a language, this is an opportunity to start from scratch. We know the various use cases we're trying to solve for, and we have carte blanche authority to craft it just how we like from the start.</p><p>We could delegate creation of the language to an engineer, who knows what's most convenient and efficient. But that would result in a very plain and uninspired language –&nbsp;one&nbsp;that gets the job done in the driest way possible,&nbsp;like almost all the other languages we have.&nbsp;Instead,&nbsp;let's find someone with a broader vision, and an appreciation for usability (not just efficiency). Let's get a <em>designer</em> to design this language. What they create will not only be expressive and intuitive, but it will appeal to those who've never programmed before. Designers should be as able as anyone else to express themselves through code.</p><p>Implicit in this talk about language is an assumption that languages must be textual. But that's only part of the story; historically most people communicated verbally (and were illiterate) or visually (because their written language was pictographic). Alphabets (where a single symbol can represent anything)&nbsp;severed the tie between meaning and appearance, and people (like me) who think visually have been struggling ever since. I thrive on diagrams, charts, illustrations, and photos. I appreciate typography, not text. And there are many people like me, for whom a screen of code is no more intuitive than a book of Arabic. It begs an obvious question:&nbsp;Why is code always textual? Why aren't there options to program visually? The question becomes even more urgent when we consider that most programs (or apps) today are intended for consumer use, not for use in the background or on a text terminal.</p><p>Some languages have adopted visual elements.&nbsp;<a href="http://Communication stylesSome people are text learners. They thrive in code. I am less in this camp. Some people are visual learners. They thrive on diagrams and visuals. I am more in this camp. Why is coding text only? Why aren't there options to program visually? The kids language does this and Quartz Composer does it but those aren't general purpose languages. What I'm proposing is a general purpose language that is graphical. (Possibly add an option for text as well but only if the text option doesn't compromise the other aims of the language).">Scratch</a> presents&nbsp;text with formatting like colors and nesting. I used <a target="_blank" href="http://www.jgrasp.org/">jGrasp</a> in college, which provided visualizations of variables and objects. Although the feature was difficult to use, the concept was brilliant. And&nbsp;<a target="_blank" href="http://en.wikipedia.org/wiki/Quartz_Composer">Quartz Composer</a> presents animations as a storyboard, a much better way to understand something that's inherently visual. But Quartz only does animations.&nbsp;What I'm proposing is a general purpose graphical programming language. Photoshop made image processing as simple as clicking and dragging. Programming can and should be the same way.</p><p>With this new language, what's important is the user's intent. What are they trying to accomplish or express? The user will define the data model (which describes things they want to store and manipulate), and the behaviors they want to engage in. It's fundamentally an&nbsp;object-oriented approach, which I support because it conforms to how we think about our world. We think of objects we can manipulate (using functions) and that have certain properties (or fields). Given that most of our goods come out of factories, the notion of a template (or class) and individual objects make sense. The prevalence of object-oriented programming is actually a strong reason to make programming visual, because the two dovetail so nicely.</p><p>By communicating visually, and by communicating about intent, this abstracts the design and functionality away from the underlying code. It separates&nbsp;software design (which we can all do) from software engineering (which computers should do automatically). After all, isn't that why we have computers? To automate things? We only have software engineers because we haven't developed tools or languages&nbsp;to accept input from non-engineers.</p><p>Obviously, many engineers&nbsp;fear this simplification, because it threatens their fiefdom (and high salaries). No one wants to be replaced. But it doesn't make sense for us to keep writing the same&nbsp;code snippets (in different languages)&nbsp;and keep teaching one another the same programming techniques when we could spend that time removing complexity. It's time for humans to take control of language and craft it to our needs, not the needs of computers.</p><p> </p><p><!--EndFragment--></p><h3>Step 2: Reinvent the tools<!--StartFragment--></h3><p>We have the right to design whatever tools we want. So why do we accept crappy ones? (Again, I suspect it's largely a matter of historical convenience and "Good Enough" Syndrome).</p><p>There's a ton that tools (like integrated development environments, which engineers generally use)&nbsp;could have that would&nbsp;improve the experience of programming. The most important is that the tool be friendly and empathetic. Those probably aren't words you've heard used to describe software, but you might be surprised. <a target="_blank" href="http://bohemiancoding.com/sketch/">Sketch</a> makes design software feel personal. And <a href="https://www.fiftythree.com/paper">Paper</a>, more than any tool I've ever used, enables serendipitous expression. Apps like these rethink the relationship between tool and artist, by putting the artist firmly back in control. They empower rather than hinder.</p><p><span>We often spend weeks or months reading a book before we dive into the code. Why is this? Is it really because we're not skilled enough to make something yet? More likely, it's because the tool is difficult to set up, and the language isn't welcoming to beginners. Here's an easy win. Just as games like FarmVille walk you through a tutorial when you start, and present a giant question mark in the corner of the screen for&nbsp;later questions, the tools we use should make it dead simple to get started. They should make introductions fast and practical, so you can get running on something appropriate to your skill level. I often find tutorials daunting, because they present way too much information, in a dry format, with way more technical detail than I need as a beginner.&nbsp;I can only guess how many people abandon tools because they never get a proper introduction. The tutorial, especially for getting started, isn't an optional feature. It must be an integral part of the programming tool.</span></p><p>The first&nbsp;improvement that any first-year college student will suggest is to introduce friendly error messages. Beginners, in particular, will find themselves simultaneously&nbsp;confused and frustrated by error messages, most of which are cryptic. Confused, because the messages are often unhelpfully vague or use overly technical language, and frustrated, because the tool doesn't provide any advice on what to fix or how to fix it. Strange, because if the tool knows what's wrong it surely knows what's right instead. I'm confident the people building this tools know how to make them simpler; they're highly skilled. But they probably don't realize or appreciate the struggles that beginners face. New programmers want feedback that makes sense in common English, and helps them avoid making the same mistake in the future. Actually, all of us want that. Whether it's a missing semicolon or a much bigger problem, we appreciate it when the tool helps us investigate and solve the problem. And when we&nbsp;(or thousands of people around the world) keep making the same mistake, the tool should <a target="_blank" href="https://www.coursera.org/course/ml">notice that</a> and provide proactive help to others in the future.</p><p>We use tools because they're helpful, but they don't always provide the right amount of help at the right time. This is especially true for new programmers who find themselves stuck. <span>The most we can say is that tools will complete a line of code or add brackets - neither of which helps with the bigger issue of program design.&nbsp;</span>It should be the job of our tools to notice perilous&nbsp;situations and provide help. If a programmer is opening the code editor for the first time ever, how about walking them through a "hello world" program? If someone made steady progress&nbsp;for 15 minutes but has slowed down, it might be time to help them debug.&nbsp;If someone is using an advanced feature when a simpler one will do, why not point that out? We put so much pressure on the engineer to know everything about the language, we forget that humans aren't even biologically equipped to remember so much, and nor is it an efficient use of our time and energy. (Again, we have computers to automate calculations&nbsp;and store large amounts of data, so we don't have to).</p><p>The most suggestions are ones that teach the user - about a new thing to try, or about an optimization for what they've already made.&nbsp;<span>The computer is only half of the story, though. Good tools become great tools&nbsp;when you leverage a&nbsp;community of other programmers.</span></p><p><span>If you're trying to accomplish something&nbsp;that other people in the community have already done, the tool would&nbsp;suggest that. "It looks like you're making a login form. Do you want to use this&nbsp;form that Sam in Indiana made?" And&nbsp;instead of downloading their code and creating a separate copy, the tool would provide a way to reference it as if it were your own. In turn, you could share what you've developed with others.</span></p><p> </p><p>What I've just described is programming as a fun, friendly, and engaging&nbsp;endeavor. One redesigned around users. Designed for everyone. Relevant to girls. Relevant to kids. Relevant to grandma. Democratic. Empowering. Productivity-boosting. Achievement-enabling. It's a style of programming that doesn't hold you back. That facilitates your expressiveness&nbsp;instead of hindering it.</p><p>It's programming&nbsp;for the modern day. Accessible to everyone.</p><p> </p><h2>Implementation</h2><p>If there's one (unfortunate) thing GamerGate has taught us, it's that people don't like change. They get territorial about their hobbies and&nbsp;feel threatened when other people try to democratize them. Then they <a target="_blank" href="http://femfreq.tumblr.com/post/109319269825/one-week-of-harassment-on-twitter">lash out</a>, to the harm of all involved.&nbsp;I'm sure some in the old guard of programmers will feel threatened by these ideas. They may dismiss them as unrealistic, or may retort that people just need to&nbsp;tough it out. And this old guard is&nbsp;entitled to their beliefs. It takes a while for people to get comfortable with new ideas. But make no mistake: programming is changing. It's&nbsp;becoming more accessible. You can't stop this tide any more than <a target="_blank" href="http://www.freep.com/story/opinion/contributors/2015/02/16/alabama-sex/23516421/">a judge in Alabama can stop same-sex marriage</a>. If you have something to contribute, please do. But we will not wait for you to accept a world in which everyone can participate.</p><p><!--EndFragment--></p><p><!--EndFragment--></p><p>Existing programmers can be the most helpful group in this entire process, because they can build the tools that make it easier for everyone else to do great work. Don't be discouraged by the amount of work at hand.&nbsp;Even when it's difficult, know that it's quite possible to democratize complex things. We've democratized computing in general, which used to require knowledge of the command line. We've also democratized more specific areas like word processing, which used to be the domain of secretaries. We've democratized access to prototyping with 3D printers and maker spaces. If we've done all of this, surely we can empower a busy working mom to build a timer&nbsp;app!<!--StartFragment--></p><p>The inevitable question:&nbsp;who will take this on?&nbsp;Google would be an obvious choice. They know how to make complex technologies simple for people to use. They strive to <a target="_blank" href="https://www.youtube.com/watch?v=TRmgMe2STL0">empower people to express themselves through technology</a>.&nbsp;They're great about surfacing user-generated content,&nbsp;which would help build a strong library of reusable code. They invest heavily in open source through&nbsp;Chromium and Hadoop, among other projects. They've begun&nbsp;to think&nbsp;more holistically about problems, designing the software, the apps, and sometimes the hardware too.&nbsp;And, most importantly, their culture is open to this kind of experimentation and to the notion of increasing accessibility.<!--StartFragment--></p><p>A few people have tried to make a universal language –&nbsp;or at least one that's more intelligible. These were either compromised in an effort to see public release, killed by lack of resources, or abandoned&nbsp;for lack of confidence in the vision and the idea that it's possible. And efforts to provide an end-to-end solution for programming have fallen apart for many of the same reasons. No company has seriously committed to&nbsp;making every component and making each perfect.</p><p>What if we try? What if we get together a few motivated individuals who believe&nbsp;deeply in this concept to guide it and protect the vision? And what if we get the backing of a community or an organization that's willing to build this out and see it go big?</p><p>It's impossible. And then&nbsp;we do it.</p>

    </div>
</body>
</html>